# 2013 August 27
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
# This file implements regression tests for SQLite library.  The
# focus of this script is testing the file name handling provided
# by the "win32-longpath" VFS.
#

if {$tcl_platform(platform)!="windows"} return

set testdir [file dirname $argv0]
source $testdir/tester.tcl
set testprefix win32longpath

proc do_remove_win32_dir {args} {
  set nRetry [getFileRetries]     ;# Maximum number of retries.
  set nDelay [getFileRetryDelay]  ;# Delay in ms before retrying.

  foreach dirName $args {
    # On windows, sometimes even a [remove_win32_dir] can fail just after
    # a directory is emptied. The cause is usually "tag-alongs" - programs
    # like anti-virus software, automatic backup tools and various explorer
    # extensions that keep a file open a little longer than we expect,
    # causing the delete to fail.
    #
    # The solution is to wait a short amount of time before retrying the
    # removal.
    #
    if {$nRetry > 0} {
      for {set i 0} {$i < $nRetry} {incr i} {
        set rc [catch {
          remove_win32_dir $dirName
        } msg]
        if {$rc == 0} break
        if {$nDelay > 0} { after $nDelay }
      }
      if {$rc} { error $msg }
    } else {
      remove_win32_dir $dirName
    }
  }
}

proc do_delete_win32_file {args} {
  set nRetry [getFileRetries]     ;# Maximum number of retries.
  set nDelay [getFileRetryDelay]  ;# Delay in ms before retrying.

  foreach fileName $args {
    # On windows, sometimes even a [delete_win32_file] can fail just after
    # a file is closed. The cause is usually "tag-alongs" - programs like
    # anti-virus software, automatic backup tools and various explorer
    # extensions that keep a file open a little longer than we expect,
    # causing the delete to fail.
    #
    # The solution is to wait a short amount of time before retrying the
    # delete.
    #
    if {$nRetry > 0} {
      for {set i 0} {$i < $nRetry} {incr i} {
        set rc [catch {
          delete_win32_file $fileName
        } msg]
        if {$rc == 0} break
        if {$nDelay > 0} { after $nDelay }
      }
      if {$rc} { error $msg }
    } else {
      delete_win32_file $fileName
    }
  }
}

db close
set path [file nativename [get_pwd]]
sqlite3 db [file join $path test.db] -vfs win32-longpath

do_test 1.1 {
  db eval {
    BEGIN EXCLUSIVE;
    CREATE TABLE t1(x);
    INSERT INTO t1 VALUES(1);
    INSERT INTO t1 VALUES(2);
    INSERT INTO t1 VALUES(3);
    INSERT INTO t1 VALUES(4);
    SELECT x FROM t1 ORDER BY x;
    COMMIT;
  }
} {1 2 3 4}

set longPath(1) \\\\?\\$path\\[pid]
make_win32_dir $longPath(1)

set longPath(2) $longPath(1)\\[string repeat X 255]
make_win32_dir $longPath(2)

set longPath(3) $longPath(2)\\[string repeat Y 255]
make_win32_dir $longPath(3)

set fileName $longPath(3)\\test.db

do_test 1.2 {
  list [catch {sqlite3 db2 [string range $fileName 4 end]} msg] $msg
} {1 {unable to open database file}}

sqlite3 db3 $fileName -vfs win32-longpath

do_test 1.3 {
  db3 eval {
    BEGIN EXCLUSIVE;
    CREATE TABLE t1(x);
    INSERT INTO t1 VALUES(5);
    INSERT INTO t1 VALUES(6);
    INSERT INTO t1 VALUES(7);
    INSERT INTO t1 VALUES(8);
    SELECT x FROM t1 ORDER BY x;
    COMMIT;
  }
} {5 6 7 8}

db3 close
# puts "  Database exists \{[exists_win32_path $fileName]\}"

sqlite3 db3 $fileName -vfs win32-longpath

do_test 1.4 {
  db3 eval {
    PRAGMA journal_mode = WAL;
  }
} {wal}

do_test 1.5 {
  db3 eval {
    BEGIN EXCLUSIVE;
    INSERT INTO t1 VALUES(9);
    INSERT INTO t1 VALUES(10);
    INSERT INTO t1 VALUES(11);
    INSERT INTO t1 VALUES(12);
    SELECT x FROM t1 ORDER BY x;
    COMMIT;
  }
} {5 6 7 8 9 10 11 12}

db3 close
# puts "  Database exists \{[exists_win32_path $fileName]\}"

do_delete_win32_file $fileName
# puts "  Files remaining \{[find_win32_file $longPath(3)\\*]\}"

do_remove_win32_dir $longPath(3)
do_remove_win32_dir $longPath(2)
do_remove_win32_dir $longPath(1)

finish_test
