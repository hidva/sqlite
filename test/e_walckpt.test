# 2014 December 04
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
source $testdir/lock_common.tcl
source $testdir/wal_common.tcl
set testprefix e_walckpt

# The following two commands are used to determine if any of the files
# "test.db", "test.db2" and "test.db3" are modified by a test case.
#
# The [save_db_hashes] command saves a hash of the current contents of
# all three files in global variables. The [compare_db_hashes] compares
# the current contents with the saved hashes and returns a list of the
# files that have changed.
#
proc save_db_hashes {} {
  global H
  foreach f {test.db test.db2 test.db3} {
    set H($f) 0
    catch { set H($f) [md5file $f] }
  }
}
proc compare_db_hashes {} {
  global H
  set ret [list]
  foreach f {test.db test.db2 test.db3} {
    set expect 0
    catch { set expect [md5file $f] }
    if {$H($f) != $expect} { lappend ret $f }
  }
  set ret
}


# The following tests are run 3 times, each using a different method of 
# invoking a checkpoint:
#
#   1) Using sqlite3_wal_checkpoint_v2()
#   2) Using "PRAGMA wal_checkpoint"
#   3) Using sqlite3_wal_checkpoint() in place of checkpoint_v2(PASSIVE)
#
# Cases (2) and (3) are to show that the following statements are 
# correct, respectively:
#
# EVIDENCE-OF: R-36706-10507 The PRAGMA wal_checkpoint command can be
# used to invoke this interface from SQL.
#
# EVIDENCE-OF: R-41613-20553 The sqlite3_wal_checkpoint(D,X) is
# equivalent to
# sqlite3_wal_checkpoint_v2(D,X,SQLITE_CHECKPOINT_PASSIVE,0,0).
# 
foreach {tn script} {
  1 {
    proc checkpoint {db mode args} {
      eval sqlite3_wal_checkpoint_v2 [list $db] [list $mode] $args
    }
  }

  2 {
    proc checkpoint {db mode args} {
      set sql "PRAGMA wal_checkpoint"
      if {[llength $args] && [lindex $args 0]!=""} {
        set sql "PRAGMA [lindex $args 0].wal_checkpoint"
      }
      set rc [catch { $db eval $sql } msg]
      if {$rc} {
        regsub {database} $msg {database:} msg
        error "[sqlite3_errcode $db] - $msg"
      }
      set msg
    }
  }

  3 {
    proc checkpoint {db mode args} {
      if {$mode == "passive"} {
        set rc [eval sqlite3_wal_checkpoint [list $db] $args]
        if {$rc != "SQLITE_OK"} {
          error "$rc - [sqlite3_errmsg $db]"
        }
      } else {
        eval sqlite3_wal_checkpoint_v2 [list $db] [list $mode] $args
      }
    }
  }

} {

  eval $script

  reset_db
  forcedelete test.db2 test.db3 test.db4
  execsql {
    ATTACH 'test.db2' AS aux;
    ATTACH 'test.db3' AS aux2;
    ATTACH 'test.db4' AS aux3;
    CREATE TABLE t1(x);
    CREATE TABLE aux.t2(x);
    CREATE TABLE aux2.t3(x);
    CREATE TABLE aux3.t4(x);
    PRAGMA main.journal_mode = WAL;
    PRAGMA aux.journal_mode = WAL;
    PRAGMA aux2.journal_mode = WAL;
    /* Leave aux4 in rollback mode */
  }

  # EVIDENCE-OF: R-49787-09095 The sqlite3_wal_checkpoint_v2(D,X,M,L,C)
  # interface runs a checkpoint operation on database X of database
  # connection D in mode M. Status information is written back into
  # integers pointed to by L and C.
  #
  #     Tests 1, 2 and 3 below verify the "on database X" part of the
  #     above. Other parts of this requirement are tested below.
  #
  # EVIDENCE-OF: R-00653-06026 If parameter zDb is NULL or points to a
  # zero length string, then the specified operation is attempted on all
  # WAL databases attached to database connection db.
  #
  #     Tests 4 and 5 below test this.
  #
  foreach {tn2 zDb dblist} {
    1 main  test.db
    2 aux   test.db2
    3 aux2  test.db3
    4 ""    {test.db test.db2 test.db3}
    5 -     {test.db test.db2 test.db3}
    6 temp  {}
  } {
    do_test $tn.1.$tn2 {
      execsql {
        INSERT INTO t1 VALUES(1);
        INSERT INTO t2 VALUES(2);
        INSERT INTO t3 VALUES(3);
      }
      save_db_hashes

      if {$zDb == "-"} {
        checkpoint db passive
      } else {
        checkpoint db passive $zDb
      }

      compare_db_hashes
    } $dblist
  }

  # EVIDENCE-OF: R-38207-48996 If zDb is not NULL (or a zero length
  # string) and is not the name of any attached database, SQLITE_ERROR is
  # returned to the caller.
  do_test $tn.2.1 {
    list [catch { checkpoint db passive notadb } msg] $msg
  } {1 {SQLITE_ERROR - unknown database: notadb}}

  # EVIDENCE-OF: R-14303-42483 If database zDb is the name of an attached
  # database that is not in WAL mode, SQLITE_OK is returned and both
  # *pnLog and *pnCkpt set to -1.
  #
  if {$tn==3} {
    # With sqlite3_wal_checkpoint() the two output variables cannot be 
    # tested. So just test that no error is returned when attempting to
    # checkpoint a db in rollback mode.
    do_test $tn.2.2.a { checkpoint db passive aux3 } {}
  } else {
    do_test $tn.2.2.b { checkpoint db passive aux3 } {0 -1 -1}
  }

  # EVIDENCE-OF: R-62028-47212 All calls obtain an exclusive "checkpoint"
  # lock on the database file.
  db close
  testvfs tvfs
  tvfs filter xShmLock
  tvfs script filelock
  proc filelock {method file handle details} {
    # Test for an exclusive checkpoint lock. A checkpoint lock locks a
    # single byte starting at offset 1.
    if {$details == "1 1 lock exclusive"} { set ::seen_checkpoint_lock 1 }
  }
  sqlite3 db test.db -vfs tvfs
  do_test $tn.3.1 {
    execsql { INSERT INTO t1 VALUES('xyz') }
    unset -nocomplain ::seen_checkpoint_lock
    checkpoint db passive
    set ::seen_checkpoint_lock
  } {1}
  db close
  tvfs delete
  reset_db


 

  #-----------------------------------------------------------------------
  # EVIDENCE-OF: R-10421-19736 If any other process is running a
  # checkpoint operation at the same time, the lock cannot be obtained and
  # SQLITE_BUSY is returned.
  #
  # EVIDENCE-OF: R-53820-33897 Even if there is a busy-handler configured,
  # it will not be invoked in this case.
  #
  testvfs tvfs
  tvfs filter xWrite
  sqlite3 db test.db -vfs tvfs
  sqlite3 db2 test.db -vfs tvfs

  do_test $tn.3.2.1 {
    db2 eval {
      PRAGMA journal_mode = WAL;
      CREATE TABLE t1(x, y);
      INSERT INTO t1 VALUES(1,2);
      INSERT INTO t1 VALUES(3,4);
      INSERT INTO t1 VALUES(5,6);
    }
    file size test.db-wal
  } [wal_file_size 5 1024]


  # Connection [db] runs a checkpoint. During this checkpoint, each
  # time it calls xWrite() to write a page into the database file, we
  # attempt to start a checkpoint using [db2]. According to the 
  # first requirement being tested, this should return SQLITE_BUSY. According
  # to the second, the busy-handler belonging to [db2] should not be
  # invoked.
  #
  set ::write_count 0
  set ::write_errors [list]
  proc busy_callback {args} {
    lappend ::write_errors "busy handler called!"
  }
  proc write_callback {args} {
    set rc [catch {checkpoint db2 passive} msg]
    if {0==[regexp "database is locked" $msg] && $msg!="1 -1 -1"} {
      lappend ::write_errors "$rc $msg"
    } 
    incr ::write_count
  }
  db2 busy busy_callback
  tvfs script write_callback

  do_test $tn.3.2.2 {
    db eval {SELECT * FROM sqlite_master}
    checkpoint db full
    set ::write_count
  } {2}

  do_test $tn.3.2.3 {
    set ::write_errors
  } {}

  db close
  db2 close
  tvfs delete

}

#-----------------------------------------------------------------------
# EVIDENCE-OF: R-03996-12088 The M parameter must be a valid checkpoint
# mode:
#
#   Valid checkpoint modes are 0, 1, 2 and 3.
#
sqlite3 db test.db
foreach {tn mode res} {
  0 -1001    {1 {SQLITE_MISUSE - not an error}}
  1 -1       {1 {SQLITE_MISUSE - not an error}}
  2  0       {0 {0 -1 -1}}
  3  1       {0 {0 -1 -1}}
  4  2       {0 {0 -1 -1}}
  5  3       {0 {0 -1 -1}}
  6  4       {1 {SQLITE_MISUSE - not an error}}
  7  114     {1 {SQLITE_MISUSE - not an error}}
  8  1000000 {1 {SQLITE_MISUSE - not an error}}
} {
  do_test 4.$tn {
    list [catch "sqlite3_wal_checkpoint_v2 db $mode" msg] $msg
  } $res
}


finish_test
