# 2010 September 1
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl

db close

do_test quota-1.1 { sqlite3_quota_initialize nosuchvfs 1 } {SQLITE_ERROR}
do_test quota-1.2 { sqlite3_quota_initialize "" 1 }        {SQLITE_OK}
do_test quota-1.3 { sqlite3_quota_initialize "" 1 }        {SQLITE_MISUSE}
do_test quota-1.4 { sqlite3_quota_shutdown }               {SQLITE_OK}

do_test quota-1.5 { sqlite3_quota_initialize "" 0 }        {SQLITE_OK}
do_test quota-1.6 { sqlite3_quota_shutdown }               {SQLITE_OK}
do_test quota-1.7 { sqlite3_quota_initialize "" 1 }        {SQLITE_OK}
do_test quota-1.8 { sqlite3_quota_shutdown }               {SQLITE_OK}


#-------------------------------------------------------------------------
# Some simple warm-body tests with a single database file in rollback 
# mode:
#
#   quota-2.1.*: Test that SQLITE_FULL is returned if the database would
#                exceed the configured quota.
#
#   quota-2.2.*: Test that SQLITE_FULL is not returned and the database
#                grows if the callback extends the quota when the database
#                attempts to grow beyond the configured quota.
#
#   quota-2.3.*: Open and close a db that is not part of any quota group. At
#                one point this was causing mutex refs to be leaked.
#
#   quota-2.4.*: Try to shutdown the quota system before closing the db
#                file. Check that this fails and the quota system still works
#                afterwards. Then close the database and successfully shut
#                down the quota system.
#   
sqlite3_quota_initialize "" 1

proc quota_check {filename limitvar size} {
  upvar $limitvar limit

  lappend ::quota [set limit] $size
  if {[info exists ::quota_request_ok]} { set limit $size }
}

do_test quota-2.1.1 {
  sqlite3_quota_set *test.db 4096 quota_check
} {SQLITE_OK}
do_test quota-2.1.2 {
  sqlite3 db test.db
  execsql {
    PRAGMA page_size=1024;
    PRAGMA auto_vacuum=OFF;
    PRAGMA journal_mode=DELETE;
  }
  set ::quota [list]
  execsql {
    CREATE TABLE t1(a, b);
    INSERT INTO t1 VALUES(1, randomblob(1100));
    INSERT INTO t1 VALUES(2, randomblob(1100));
  }
  set ::quota
} {}
do_test quota-2.1.3 { file size test.db } {4096}
do_test quota-2.1.4 {
  catchsql { INSERT INTO t1 VALUES(3, randomblob(1100)) }
} {1 {database or disk is full}}
do_test quota-2.1.5 { set ::quota } {4096 5120}

set ::quota_request_ok 1
set ::quota [list]
do_test quota-2.2.1 {
  execsql { INSERT INTO t1 VALUES(3, randomblob(1100)) }
} {}
do_test quota-2.2.2 { set ::quota } {4096 5120}
do_test quota-2.2.3 { file size test.db } {5120}
unset ::quota_request_ok

do_test quota-2.3.1 {
  sqlite3 db2 bak.db
  db2 close
} {}

do_test quota-2.4.1 {
  sqlite3_quota_shutdown
} {SQLITE_MISUSE}
set ::quota [list]
do_test quota-2.4.2 {
  catchsql { INSERT INTO t1 VALUES(3, randomblob(1100)) }
} {1 {database or disk is full}}
do_test quota-2.4.3 { set ::quota } {5120 6144}
do_test quota-2.4.4 { file size test.db } {5120}
do_test quota-2.4.99 {
  db close
  sqlite3_quota_shutdown
} {SQLITE_OK}

#-------------------------------------------------------------------------
# Try some tests with more than one connection to a database file. Still
# in rollback mode.
#
proc quota_check {filename limitvar size} {
  upvar $limitvar limit
  lappend ::quota [set limit] $size
  if {[info exists ::quota_request_ok]} { set limit $size }
}

do_test quota-3.1.1 {
  file delete -force test.db
  sqlite3_quota_initialize "" 1
  sqlite3_quota_set *test.db 4096 quota_check
} {SQLITE_OK}

do_test quota-3.1.2 {
  sqlite3 db test.db
  execsql {
    PRAGMA page_size = 1024;
    PRAGMA journal_mode = delete;
    PRAGMA auto_vacuum = off;
    CREATE TABLE t1(a PRIMARY KEY, b);
    INSERT INTO t1 VALUES(1, 'one');
  }
  file size test.db
} {3072}
do_test quota-3.1.3 {
  sqlite3 db2 test.db
  set ::quota [list]
  execsql { CREATE TABLE t2(a, b) } db2
  set ::quota
} {}
puts "quotas: [sqlite3_quota_dump]"

do_test quota-3.X {
  catch { db close }
  catch { db2 close }
} {0}

#-------------------------------------------------------------------------
# Quotas are deleted when unused and when there limit is set to zero
#

# Return a list of all currently defined quotas.  Each quota is identified
# by its pattern.
proc quota_list {} {
  set allq {}
  foreach q [sqlite3_quota_dump] {
    lappend allq [lindex $q 0]
  }
  return [lsort $allq]
}
do_test quota-4.1 {
  sqlite3_quota_set *test.db 0 {}
  quota_list
} {}
do_test quota-4.2 {
  sqlite3_quota_set *test.db 4096 {}
  quota_list
} {*test.db}


sqlite3_quota_shutdown 
finish_test
