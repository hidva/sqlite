# 2011 April 22
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl

# Test organization:
#
#   1.*: That file names are correctly extracted from URIs.
#   2.*: That URI options (query parameters) are correctly extracted from URIs.
#   3.*: That specifying an unknown VFS causes an error.
#   4.*: Tests for specifying other options (other than "vfs").
#   5.*: Test using a different VFS with an attached database.
#

set testprefix uri
db close
sqlite3_shutdown
sqlite3_config_uri 1

#-------------------------------------------------------------------------
# Test that file names are correctly extracted from URIs.
#
foreach {tn uri file} {
  1      test.db                            test.db
  2      file:test.db                       test.db
  3      file://an-authorityPWD/test.db     test.db
  4      file:PWD/test.db                   test.db
  5      file:test.db?mork=1                test.db
  6      file:test.db?mork=1&tonglor=2      test.db
  7      file:test.db?mork=1#boris          test.db
  8      file:test.db#boris                 test.db
  9      test.db#boris                      test.db#boris
  10     test.db?mork=1#boris               test.db?mork=1#boris
  11     file:test%2Edb                     test.db
  12     file                               file
  13     http:test.db                       http:test.db
  14     file://xyzPWD/test.db%3Fhello      test.db?hello
  15     file:test.db%00extra               test.db
  16     file:test%00.db%00extra            test
} {
  set uri  [string map [list PWD [pwd]] $uri]
  set file [string map [list PWD [pwd]] $file]

  forcedelete $file
  do_test 1.$tn.1 { file exists $file } 0
  set DB [sqlite3_open $uri]
  do_test 1.$tn.2 { file exists $file } 1
  sqlite3_close $DB
  forcedelete $file

  do_test 1.$tn.3 { file exists $file } 0
  sqlite3 db xxx.db
  execsql { ATTACH $uri AS aux }
  do_test 1.$tn.4 { file exists $file } 1
  db close
}


#-------------------------------------------------------------------------
# Test that URI query parameters are passed through to the VFS layer
# correctly.
#
testvfs tvfs -default 1
tvfs filter xOpen
tvfs script open_method
proc open_method {method file arglist} {
  set ::arglist $arglist
}
foreach {tn uri kvlist} {
  1      file:test.db?hello=world                     {hello world}
  2      file:test.db?hello&world                     {hello {} world {}}
  3      file:test.db?hello=1&world=2&vfs=tvfs        {hello 1 world 2 vfs tvfs}
  4      file:test.db?hello=1&world=2&vfs=unix        {}
  5      file:test.db?%68%65%6C%6C%6F=%77%6F%72%6C%64 {hello world}
  6      file:test%00.db?hello%00extra=world%00ex     {hello world}
  7      file:test%00.db?hello%00=world%00            {hello world}
  8      file:test%00.db?=world&xyz=abc               {xyz abc}
  9      file:test.db?%00hello=world&xyz=abc          {xyz abc}
  10     file:test.db?hello=%00world&xyz=             {hello {} xyz {}}
  11     file:test.db?=#ravada                        {}
  12     file:test.db?&&&&&&&&hello=world&&&&&&&      {hello world}
  13     test.db?&&&&&&&&hello=world&&&&&&&           {}
  14     http:test.db?hello&world                     {}
} {
  set ::arglist ""
  set DB [sqlite3_open $uri]
  do_test 2.$tn.1 { set ::arglist } $kvlist
  sqlite3_close $DB

  sqlite3 db xxx.db
  set ::arglist ""
  execsql { ATTACH $uri AS aux }
  do_test 2.$tn.2 { set ::arglist } $kvlist
  db close
}
tvfs delete

#-------------------------------------------------------------------------
# Test that specifying a non-existent VFS raises an error.
#
do_test 3.1 {
  list [catch { sqlite3 db "file:test.db?vfs=nosuchvfs" } msg] $msg
} {1 {no such vfs: nosuchvfs}}

#-------------------------------------------------------------------------
# Test some of the other options (other than "vfs").
#
# TODO: Fix this after the list of options is decided.
#
do_test 4.0 {
  sqlite3 db test.db
  db eval {CREATE TABLE t1(a, b)}
  db close
} {}
foreach {tn uri ro} {
  1    "file:test.db"                                 0
  2    "file:test.db?readonly=0"                      0
  3    "file:test.db?readonly=1&readwrite=0&create=0" 1
} {
  set RES(0) {0 {}}
  set RES(1) {1 {attempt to write a readonly database}}

  do_test 4.$tn {
    sqlite3 db $uri
    catchsql { INSERT INTO t1 VALUES(1, 2) }
  } $RES($ro)
  db close
}

#-------------------------------------------------------------------------
# Test that things work if an ATTACHed database uses a different VFS than
# the main database. The important point is that for all operations 
# involving the ATTACHed database, the correct versions of the following
# VFS are used for all operations involving the attached database.
#
#     xOpen
#     xDelete
#     xAccess
#     xFullPathname
#

# This block of code creates two VFS - "tvfs1" and "tvfs2". Each time one
# of the above methods is called using "tvfs1", global variable ::T1(X) is
# set, where X is the file-name the method is called on. Calls to the above
# methods using "tvfs2" set entries in the global T2 array.
#
testvfs tvfs1 
tvfs1 filter {xOpen xDelete xAccess xFullPathname}
tvfs1 script tvfs1_callback
proc tvfs1_callback {method filename args} { 
  set ::T1([file tail $filename]) 1 
}
testvfs tvfs2 
tvfs2 filter {xOpen xDelete xAccess xFullPathname}
tvfs2 script tvfs2_callback
proc tvfs2_callback {method filename args} { 
  set ::T2([file tail $filename]) 1 
}

eval forcedelete [glob test.db*]
do_test 5.1.1 {
  sqlite3 db file:test.db1?vfs=tvfs1
  execsql {
    ATTACH 'file:test.db2?vfs=tvfs2' AS aux;
    PRAGMA main.journal_mode = PERSIST;
    PRAGMA aux.journal_mode = PERSIST;
    CREATE TABLE t1(a, b);
    CREATE TABLE aux.t2(a, b);
    PRAGMA main.journal_mode = WAL;
    PRAGMA aux.journal_mode = PERSIST;
    INSERT INTO t1 VALUES('x', 'y');
    INSERT INTO t2 VALUES('x', 'y');
  }
  lsort [array names ::T1]
} {test.db1 test.db1-journal test.db1-wal}

do_test 5.1.2 {
  lsort [array names ::T2]
} {test.db2 test.db2-journal test.db2-wal}

db close
tvfs1 delete
tvfs2 delete

finish_test

