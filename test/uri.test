# 2011 April 22
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl

set testprefix uri
db close
sqlite3_shutdown
sqlite3_config_uri 1

#-------------------------------------------------------------------------
# Test that file names are correctly extracted from URIs.
#
foreach {tn uri file} {
  1      test.db                            test.db
  2      file:test.db                       test.db
  3      file://an-authorityPWD/test.db     test.db
  4      file:PWD/test.db                   test.db
  5      file:test.db?mork=1                test.db
  6      file:test.db?mork=1&tonglor=2      test.db
  7      file:test.db?mork=1#boris          test.db
  8      file:test.db#boris                 test.db
  9      test.db#boris                      test.db#boris
  10     test.db?mork=1#boris               test.db?mork=1#boris
  11     file:test%2Edb                     test.db
  12     file                               file
  13     http:test.db                       http:test.db
  14     file://xyzPWD/test.db%3Fhello      test.db?hello
  15     file:test.db%00extra               test.db
  16     file:test%00.db%00extra            test
} {
  set uri  [string map [list PWD [pwd]] $uri]
  set file [string map [list PWD [pwd]] $file]

  forcedelete $file
  do_test 1.$tn.1 { file exists $file } 0
  set DB [sqlite3_open $uri]
  do_test 1.$tn.2 { file exists $file } 1
  sqlite3_close $DB
  forcedelete $file

  do_test 1.$tn.3 { file exists $file } 0
  sqlite3 db xxx.db
  execsql { ATTACH $uri AS aux }
  do_test 1.$tn.4 { file exists $file } 1
  db close
}


#-------------------------------------------------------------------------
# Test that URI query parameters are passed through to the VFS layer
# correctly.
#
testvfs tvfs -default 1
tvfs filter xOpen
tvfs script open_method
proc open_method {method file arglist} {
  set ::arglist $arglist
}
foreach {tn uri kvlist} {
  1      file:test.db?hello=world                     {hello world}
  2      file:test.db?hello&world                     {hello {} world {}}
  3      file:test.db?hello=1&world=2&vfs=tvfs        {hello 1 world 2 vfs tvfs}
  4      file:test.db?hello=1&world=2&vfs=unix        {}
  5      file:test.db?%68%65%6C%6C%6F=%77%6F%72%6C%64 {hello world}
  6      file:test%00.db?hello%00extra=world%00ex     {hello world}
  7      file:test%00.db?hello%00=world%00            {hello world}
  8      file:test%00.db?=world&xyz=abc               {xyz abc}
  9      file:test.db?%00hello=world&xyz=abc          {xyz abc}
  10     file:test.db?hello=%00world&xyz=             {hello {} xyz {}}
  11     file:test.db?=#ravada                        {}
  12     file:test.db?&&&&&&&&hello=world&&&&&&&      {hello world}
  13     test.db?&&&&&&&&hello=world&&&&&&&           {}
  14     http:test.db?hello&world                     {}
} {
  set ::arglist ""
  set DB [sqlite3_open $uri]
  do_test 2.$tn.1 { set ::arglist } $kvlist
  sqlite3_close $DB

  sqlite3 db xxx.db
  set ::arglist ""
  execsql { ATTACH $uri AS aux }
  do_test 2.$tn.2 { set ::arglist } $kvlist
  db close
}
tvfs delete

#-------------------------------------------------------------------------
# Test that specifying a non-existent VFS raises an error.
#
do_test 3.1 {
  list [catch { sqlite3 db "file:test.db?vfs=nosuchvfs" } msg] $msg
} {1 {no such vfs: nosuchvfs}}

#-------------------------------------------------------------------------
# Test the "readonly" URI option.
#
do_test 4.0 {
  sqlite3 db test.db
  db eval {CREATE TABLE t1(a, b)}
  db close
} {}
foreach {tn uri ro} {
  1    "file:test.db"                                 0
  2    "file:test.db?readonly=0"                      0
  3    "file:test.db?readonly=1&readwrite=0&create=0" 1
} {
  set RES(0) {0 {}}
  set RES(1) {1 {attempt to write a readonly database}}

  do_test 4.$tn {
    sqlite3 db $uri
    catchsql { INSERT INTO t1 VALUES(1, 2) }
  } $RES($ro)
  db close
}

finish_test

