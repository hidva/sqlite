# 2014 August 30
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
#
# Test some properties of the pager_ota_mode and ota_mode pragmas.
#

set testdir [file join [file dirname $argv0] .. .. test]
source $testdir/tester.tcl
set ::testprefix ota5


# Run the OTA in file $ota on target database $target until completion.
#
proc run_ota {target ota} {
  sqlite3ota ota $target $ota
  while { [ota step]=="SQLITE_OK" } {}
  ota close
}


# Run the OTA in file $ota on target database $target one step at a
# time until completion.
#
proc step_ota {target ota} {
  while 1 {
    sqlite3ota ota $target $ota
    set rc [ota step]
    ota close
    if {$rc != "SQLITE_OK"} break
  }
  set rc
}

# Return a list of the primary key columns for table $tbl in the database
# opened by database handle $db.
#
proc pkcols {db tbl} {
  set ret [list]
  $db eval "PRAGMA table_info = '$tbl'" {
    if {$pk} { lappend ret $name }
  }
  return $ret
}

# Return a list of all columns for table $tbl in the database opened by 
# database handle $db.
#
proc allcols {db tbl} {
  set ret [list]
  $db eval "PRAGMA table_info = '$tbl'" {
    lappend ret $name
  }
  return $ret
}

# Return a checksum on all tables and data in the main database attached
# to database handle $db. It is possible to add indexes without changing
# the checksum.
#
proc datacksum {db} {

  $db eval { SELECT name FROM sqlite_master WHERE type='table' } {
    append txt $name
    set cols [list]
    set order [list]
    set cnt 0
    $db eval "PRAGMA table_info = $name" x {
      lappend cols "quote($x(name))"
      lappend order [incr cnt]
    }
    set cols [join $cols ,]
    set order [join $order ,]
    append txt [$db eval "SELECT $cols FROM $name ORDER BY $order"]
  }
  return "[string length $txt]-[md5 $txt]"
}

proc ucontrol {args} {
  set ret ""
  foreach a $args {
    if {$a} {
      append ret .
    } else {
      append ret x
    }
  }
  return $ret
}

# Argument $target is the name of an SQLite database file. $sql is an SQL
# script containing INSERT, UPDATE and DELETE statements to execute against
# it. This command creates an OTA update database in file $ota that has
# the same effect as the script. The target database is not modified by
# this command.
#
proc generate_ota_db {target ota sql} {

  forcedelete $ota
  forcecopy $target copy.db

  # Evaluate the SQL script to modify the contents of copy.db.
  #
  sqlite3 dbOta copy.db
  dbOta eval $sql

  dbOta function ucontrol ucontrol
  
  # Evaluate the SQL script to modify the contents of copy.db.
  set ret [datacksum dbOta]

  dbOta eval { ATTACH $ota AS ota }
  dbOta eval { ATTACH $target AS orig }

  dbOta eval { SELECT name AS tbl FROM sqlite_master WHERE type = 'table' } {
    set pk [pkcols dbOta $tbl]
    set cols [allcols dbOta $tbl]

    # A WHERE clause to test that the PK columns match.
    #
    set where [list]
    foreach c $pk { lappend where "main.$tbl.$c IS orig.$tbl.$c" }
    set where [join $where " AND "]
    
    # A WHERE clause to test that all columns match.
    #
    set where2 [list]
    foreach c $cols { lappend where2 "main.$tbl.$c IS orig.$tbl.$c" }
    set ucontrol "ucontrol([join $where2 ,])"
    set where2 [join $where2 " AND "]

    # Create a data_xxx table in the OTA update database.
    dbOta eval "
      CREATE TABLE ota.data_$tbl AS SELECT *, '' AS ota_control 
      FROM main.$tbl LIMIT 0
    "

    # Find all new rows INSERTed by the script.
    dbOta eval "
      INSERT INTO ota.data_$tbl 
          SELECT *, 0 AS ota_control FROM main.$tbl
          WHERE NOT EXISTS (
            SELECT 1 FROM orig.$tbl WHERE $where
          )
    "
    
    # Find all old rows DELETEd by the script.
    dbOta eval "
      INSERT INTO ota.data_$tbl 
          SELECT *, 1 AS ota_control FROM orig.$tbl
          WHERE NOT EXISTS (
            SELECT 1 FROM main.$tbl WHERE $where
          )
    "
    
    # Find all rows UPDATEd by the script.
    set origcols [list]
    foreach c $cols { lappend origcols "main.$tbl.$c" }
    set origcols [join $origcols ,]
    dbOta eval "
      INSERT INTO ota.data_$tbl
          SELECT $origcols, $ucontrol AS ota_control 
          FROM orig.$tbl, main.$tbl
          WHERE $where AND NOT ($where2)
    "

  }

  dbOta close
  forcedelete copy.db

  return $ret
}

#-------------------------------------------------------------------------
#
do_execsql_test 1.0 {
  CREATE TABLE t1(a INTEGER PRIMARY KEY, b, c);
  CREATE TABLE t2(x, y, z, PRIMARY KEY(y, z)) WITHOUT ROWID;

  INSERT INTO t1 VALUES(1, 2, 3);
  INSERT INTO t1 VALUES(2, 4, 6);
  INSERT INTO t1 VALUES(3, 6, 9);

  INSERT INTO t2 VALUES(1, 2, 3);
  INSERT INTO t2 VALUES(2, 4, 6);
  INSERT INTO t2 VALUES(3, 6, 9);
}
db close

set cksum [generate_ota_db test.db ota.db {
  INSERT INTO t1 VALUES(4, 8, 12);
  DELETE FROM t1 WHERE a = 2;
  UPDATE t1 SET c = 15 WHERE a=3;

  INSERT INTO t2 VALUES(4, 8, 12);
  DELETE FROM t2 WHERE x = 2;
  UPDATE t2 SET x = 15 WHERE z=9;
}]

foreach {tn idx} {
  1 {
  }
  2 {
    CREATE INDEX i1 ON t1(a, b, c);
    CREATE INDEX i2 ON t2(x, y, z);
  }
} {
  foreach cmd {run step} {
    forcecopy test.db test.db2
    forcecopy ota.db ota.db2

    sqlite3 db test.db2
    db eval $idx

    do_test 1.$tn.$cmd.1 {
      ${cmd}_ota test.db2 ota.db2
      datacksum db
    } $cksum

    do_test 1.$tn.$cmd.2 {
      db eval { PRAGMA integrity_check } 
    } {ok}

    db close
  }
}

#-------------------------------------------------------------------------
#


finish_test




