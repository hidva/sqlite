# 2014 June 17
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#*************************************************************************
#
# This file is focused on OOM errors.
#

source [file join [file dirname [info script]] fts5_common.tcl]
source $testdir/malloc_common.tcl
set testprefix fts5fault6

# If SQLITE_ENABLE_FTS5 is defined, omit this file.
ifcapable !fts5 {
  finish_test
  return
}

#-------------------------------------------------------------------------
# OOM while rebuilding an FTS5 table.
#
do_execsql_test 1.0 {
  CREATE VIRTUAL TABLE tt USING fts5(a, b);
  INSERT INTO tt VALUES('c d c g g f', 'a a a d g a');
  INSERT INTO tt VALUES('c d g b f d', 'b g e c g c');
  INSERT INTO tt VALUES('c c f d e d', 'c e g d b c');
  INSERT INTO tt VALUES('e a f c e f', 'g b a c d g');
  INSERT INTO tt VALUES('c g f b b d', 'g c d c f g');
  INSERT INTO tt VALUES('d a g a b b', 'g c g g c e');
  INSERT INTO tt VALUES('e f a b c e', 'f d c d c c');
  INSERT INTO tt VALUES('e c a g c d', 'b b g f f b');
  INSERT INTO tt VALUES('g b d d e b', 'f f b d a c');
  INSERT INTO tt VALUES('e a d a e d', 'c e a e f g');
}
faultsim_save_and_close

do_faultsim_test 1.1 -faults oom-t* -prep {
  faultsim_restore_and_reopen
} -body {
  db eval { INSERT INTO tt(tt) VALUES('rebuild') }
} -test {
  faultsim_test_result {0 {}}
}

do_faultsim_test 1.2 -faults oom-t* -prep {
  faultsim_restore_and_reopen
} -body {
  db eval { REPLACE INTO tt(rowid, a, b) VALUES(6, 'x y z', 'l l l'); }
} -test {
  faultsim_test_result {0 {}}
}


#-------------------------------------------------------------------------
# OOM within a special delete.
#
reset_db
do_execsql_test 2.0 {
  CREATE VIRTUAL TABLE tt USING fts5(a, content="");
  INSERT INTO tt VALUES('c d c g g f');
  INSERT INTO tt VALUES('c d g b f d');
  INSERT INTO tt VALUES('c c f d e d');
  INSERT INTO tt VALUES('e a f c e f');
  INSERT INTO tt VALUES('c g f b b d');
  INSERT INTO tt VALUES('d a g a b b');
  INSERT INTO tt VALUES('e f a b c e');
  INSERT INTO tt VALUES('e c a g c d');
  INSERT INTO tt VALUES('g b d d e b');
  INSERT INTO tt VALUES('e a d a e d');
}
faultsim_save_and_close

do_faultsim_test 2.1 -faults oom-t* -prep {
  faultsim_restore_and_reopen
} -body {
  db eval { INSERT INTO tt(tt, rowid, a) VALUES('delete', 3, 'c d g b f d'); }
} -test {
  faultsim_test_result {0 {}}
}

do_faultsim_test 2.2 -faults oom-t* -prep {
  faultsim_restore_and_reopen
} -body {
  db eval { INSERT INTO tt(tt) VALUES('delete-all') }
} -test {
  faultsim_test_result {0 {}}
}

do_faultsim_test 2.3 -faults oom-t* -prep {
  faultsim_restore_and_reopen
} -body {
  db eval { INSERT INTO tt VALUES('x y z') }
} -test {
  faultsim_test_result {0 {}}
}

#-------------------------------------------------------------------------
# OOM in the ASCII tokenizer with very large tokens. 
#
# Also the unicode tokenizer.
#
set t1 [string repeat wxyz 20]
set t2 [string repeat wxyz 200]
set t3 [string repeat wxyz 2000]
set doc "$t1 $t2 $t3"
do_execsql_test 3.0 {
  CREATE VIRTUAL TABLE xyz USING fts5(c, tokenize=ascii, content="");
  CREATE VIRTUAL TABLE xyz2 USING fts5(c, content="");
}
faultsim_save_and_close

do_faultsim_test 3.1 -faults oom-t* -prep {
  faultsim_restore_and_reopen
  db eval { SELECT * FROM xyz }
} -body {
  db eval { INSERT INTO xyz VALUES($::doc) }
} -test {
  faultsim_test_result {0 {}}
}

do_faultsim_test 3.2 -faults oom-t* -prep {
  faultsim_restore_and_reopen
  db eval { SELECT * FROM xyz2 }
} -body {
  db eval { INSERT INTO xyz2 VALUES($::doc) }
} -test {
  faultsim_test_result {0 {}}
}

#-------------------------------------------------------------------------
# OOM while initializing a unicode61 tokenizer.
#
reset_db
faultsim_save_and_close
do_faultsim_test 4.1 -faults oom-t* -prep {
  faultsim_restore_and_reopen
} -body {
  db eval { 
    CREATE VIRTUAL TABLE yu USING fts5(x, tokenize="unicode61 separators abc");
  }
} -test {
  faultsim_test_result {0 {}}
}

#-------------------------------------------------------------------------
# OOM while running a query that includes synonyms and matchinfo().
#
proc mit {blob} {
  set scan(littleEndian) i*
  set scan(bigEndian) I*
  binary scan $blob $scan($::tcl_platform(byteOrder)) r
  return $r
}
proc tcl_tokenize {tflags text} {
  foreach {w iStart iEnd} [fts5_tokenize_split $text] {
    sqlite3_fts5_token $w $iStart $iEnd
    if {$tflags=="query" && [string length $w]==1} {
      for {set i 2} {$i < 7} {incr i} {
        sqlite3_fts5_token -colo [string repeat $w $i] $iStart $iEnd
      }
    }
  }
}
proc tcl_create {args} { return "tcl_tokenize" }
reset_db
sqlite3_fts5_create_tokenizer db tcl tcl_create
db func mit mit
sqlite3_fts5_register_matchinfo db
do_test 5.0 {
  execsql { CREATE VIRTUAL TABLE t1 USING fts5(a, tokenize=tcl) }
  foreach {rowid text} {
    1 {aaaa cc b aaaaa cc aa} 
    2 {aa aa bb a bbb}
    3 {bb aaaaa aaaaa b aaaa aaaaa}
    4 {aa a b aaaa aa}
    5 {aa b ccc aaaaa cc}
    6 {aa aaaaa bbbb cc aaa}
    7 {aaaaa aa aa ccccc bb}
    8 {ccc bbbbb ccccc bbb c}
    9 {cccccc bbbb a aaa cccc c}
  } {
    execsql { INSERT INTO t1(rowid, a) VALUES($rowid, $text) }
  }
} {}

set res [list {*}{
  1 {3 24 8 2 12 6}
  5 {2 24 8 2 12 6}
  6 {3 24 8 1 12 6}
  7 {3 24 8 1 12 6}
  9 {2 24 8 3 12 6}
}]
do_execsql_test 5.1 {
  SELECT rowid, mit(matchinfo(t1, 'x')) FROM t1 WHERE t1 MATCH 'a AND c'
} $res

faultsim_save_and_close
do_faultsim_test 5.2 -faults oom* -prep {
  faultsim_restore_and_reopen
  sqlite3_fts5_create_tokenizer db tcl tcl_create
  sqlite3_fts5_register_matchinfo db
  db func mit mit
} -body {
  db eval { 
    SELECT rowid, mit(matchinfo(t1, 'x')) FROM t1 WHERE t1 MATCH 'a AND c'
  }
} -test {
  faultsim_test_result [list 0 $::res]
}

finish_test

