# 2018 March 14
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
# This file implements regression tests for SQLite library.
#

if {![info exists testdir]} {
  set testdir [file join [file dirname [info script]] .. .. test]
} 
source [file join [file dirname [info script]] session_common.tcl]
source $testdir/tester.tcl
ifcapable !session {finish_test; return}

set testprefix sessionrebase

set ::lConflict [list]
proc xConflict {args} {
  set res [lindex $::lConflict 0]
  set ::lConflict [lrange $::lConflict 1 end]
  return $res
}

#-------------------------------------------------------------------------
# The following test cases - 1.* - test that the rebase blobs output by
# sqlite3_changeset_apply_v2 look correct in some simple cases. The blob
# is itself a changeset, containing records determined as follows:
#
#   * For each conflict resolved with REPLACE, the rebase blob contains
#     a DELETE record. All fields other than the PK fields are undefined.
#
#   * For each conflict resolved with OMIT, the rebase blob contains an
#     INSERT record. For an INSERT or UPDATE operation, the indirect flag
#     is clear and all updated fields are defined. For a DELETE operation,
#     the indirect flag is set and all non-PK fields left undefined.
#
proc do_apply_v2_test {tn sql modsql conflict_handler res} {
  
  execsql BEGIN
  sqlite3session S db main
  S attach *
  execsql $sql
  set changeset [S changeset]
  S delete
  execsql ROLLBACK

  execsql BEGIN
  execsql $modsql
  set ::lConflict $conflict_handler
  set blob [sqlite3changeset_apply_v2 db $changeset xConflict]
  execsql ROLLBACK

  uplevel [list do_test $tn [list changeset_to_list $blob] [list {*}$res]]
}

do_execsql_test 1.0 {
  CREATE TABLE t1(a INTEGER PRIMARY KEY, b);
  INSERT INTO t1 VALUES(1, 'value A');
}

do_apply_v2_test 1.1.1 {
  UPDATE t1 SET b = 'value B' WHERE a=1;
} {
  UPDATE t1 SET b = 'value C' WHERE a=1;
} {
  OMIT
} {
  {INSERT t1 0 X. {} {i 1 t {value B}}}
}
do_apply_v2_test 1.1.2 {
  UPDATE t1 SET b = 'value B' WHERE a=1;
} {
  UPDATE t1 SET b = 'value C' WHERE a=1;
} {
  REPLACE
} {
  {DELETE t1 0 X. {i 1 {} {}} {}}
}

do_apply_v2_test 1.2.1 {
  INSERT INTO t1 VALUES(2, 'first');
} {
  INSERT INTO t1 VALUES(2, 'second');
} {
  OMIT
} {
  {INSERT t1 0 X. {} {i 2 t first}}
}
do_apply_v2_test 1.2.2 {
  INSERT INTO t1 VALUES(2, 'first');
} {
  INSERT INTO t1 VALUES(2, 'second');
} {
  REPLACE
} {
  {DELETE t1 0 X. {i 2 {} {}} {}}
}

do_apply_v2_test 1.3.1 {
  DELETE FROM t1 WHERE a=1;
} {
  UPDATE t1 SET b='value D' WHERE a=1;
} {
  OMIT
} {
  {INSERT t1 1 X. {} {i 1 {} {}}}
}
do_apply_v2_test 1.3.2 {
  DELETE FROM t1 WHERE a=1;
} {
  UPDATE t1 SET b='value D' WHERE a=1;
} {
  REPLACE
} {
  {DELETE t1 0 X. {i 1 {} {}} {}}
}

#-------------------------------------------------------------------------
# Test cases 2.* - simple tests of rebasing actual changesets.
#
#    2.1.1 - 1u2u1r
#    2.1.2 - 1u2u2r
#    2.1.3 - 1d2d
#    2.1.4 - 1d2u1r
#    2.1.5 - 1d2u2r !!
#    2.1.6 - 1u2d1r

proc xConflictAbort {args} {
  return "ABORT"
}

# Take a copy of database test.db in file test.db2. Execute $sql1
# against test.db and $sql2 against test.db2. Capture a changeset
# for each. Then send the test.db2 changeset to test.db and apply
# it with the conflict handlers in $conflict_handler. Patch the
# test.db changeset and then execute it against test.db2. Test that
# the two databases come out the same.
#
proc do_rebase_test {tn sql1 sql2 conflict_handler {testsql ""} {testres ""}} {

  forcedelete test.db2 test.db2-journal test.db2-wal
  forcecopy test.db test.db2
  sqlite3 db2 test.db2

  db eval BEGIN

  sqlite3session S1 db main
  S1 attach *
  execsql $sql1 db
  set c1 [S1 changeset]
  S1 delete

  sqlite3session S2 db2 main
  S2 attach *
  execsql $sql2 db2
  set c2 [S2 changeset]
  S2 delete

  set ::lConflict $conflict_handler
  set rebase [sqlite3changeset_apply_v2 db $c2 xConflict]
  #puts [changeset_to_list $rebase]

  sqlite3rebaser_create R
  R configure $rebase
  set c1r [R rebase $c1]
  R delete
  #puts [changeset_to_list $c1r]

  sqlite3changeset_apply_v2 db2 $c1r xConflictAbort

  uplevel [list do_test $tn.1 [list compare_db db db2] {}]
  db2 close

  if {$testsql!=""} {
    uplevel [list do_execsql_test $tn.2 $testsql $testres]
  }

  db eval ROLLBACK
}

reset_db
do_execsql_test 2.1.0 {
  CREATE TABLE t1 (a INTEGER PRIMARY KEY, b TEXT);
  INSERT INTO t1 VALUES(1, 'one');
  INSERT INTO t1 VALUES(2, 'two');
  INSERT INTO t1 VALUES(3, 'three');
}
do_rebase_test 2.1.1 {
  UPDATE t1 SET b = 'two.1' WHERE a=2;
} {
  UPDATE t1 SET b = 'two.2' WHERE a=2;
} {
  OMIT
} { SELECT * FROM t1 } {1 one 2 two.1 3 three}

do_rebase_test 2.1.2 {
  UPDATE t1 SET b = 'two.1' WHERE a=2;
} {
  UPDATE t1 SET b = 'two.2' WHERE a=2;
} {
  REPLACE
} { SELECT * FROM t1 } {1 one 2 two.2 3 three}

do_rebase_test 2.1.3 {
  DELETE FROM t1 WHERE a=3;
} {
  DELETE FROM t1 WHERE a=3;
} {
  OMIT
} { SELECT * FROM t1 } {1 one 2 two}

do_rebase_test 2.1.4 {
  DELETE FROM t1 WHERE a=1;
} {
  UPDATE t1 SET b='one.2' WHERE a=1
} {
  OMIT
} { SELECT * FROM t1 } {2 two 3 three}

#do_rebase_test 2.1.5 {
  #DELETE FROM t1 WHERE a=1;
#} {
  #UPDATE t1 SET b='one.2' WHERE a=1
#} {
  #REPLACE
#} { SELECT * FROM t1 } {2 two 3 three}

do_rebase_test 2.1.6 {
  UPDATE t1 SET b='three.1' WHERE a=3;
} {
  DELETE FROM t1 WHERE a=3;
} {
  OMIT
} { SELECT * FROM t1 } {1 one 2 two 3 three.1}

do_rebase_test 2.1.7 {
  UPDATE t1 SET b='three.1' WHERE a=3;
} {
  DELETE FROM t1 WHERE a=3;
} {
  REPLACE
} { SELECT * FROM t1 } {1 one 2 two}

finish_test

