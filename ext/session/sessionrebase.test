# 2018 March 14
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
# This file implements regression tests for SQLite library.
#

if {![info exists testdir]} {
  set testdir [file join [file dirname [info script]] .. .. test]
} 
source [file join [file dirname [info script]] session_common.tcl]
source $testdir/tester.tcl
ifcapable !session {finish_test; return}

set testprefix sessionrebase

set ::lConflict [list]
proc xConflict {args} {
  set res [lindex $::lConflict 0]
  set ::lConflict [lrange $::lConflict 1 end]
  return $res
}

#-------------------------------------------------------------------------
# The following test cases - 1.* - test that the rebase blobs output by
# sqlite3_changeset_apply_v2 look correct in some simple cases. The blob
# is itself a changeset, containing records determined as follows:
#
#   * For each conflict resolved with REPLACE, the rebase blob contains
#     a DELETE record. All fields other than the PK fields are undefined.
#
#   * For each conflict resolved with OMIT, the rebase blob contains an
#     INSERT record. For an INSERT or UPDATE operation, the indirect flag
#     is clear and all updated fields are defined. For a DELETE operation,
#     the indirect flag is set and all non-PK fields left undefined.
#
proc do_apply_v2_test {tn sql modsql conflict_handler res} {
  
  execsql BEGIN
  sqlite3session S db main
  S attach *
  execsql $sql
  set changeset [S changeset]
  S delete
  execsql ROLLBACK

  execsql BEGIN
  execsql $modsql
  set ::lConflict $conflict_handler
  set blob [sqlite3changeset_apply_v2 db $changeset xConflict]
  execsql ROLLBACK

  uplevel [list do_test $tn [list changeset_to_list $blob] [list {*}$res]]
}

do_execsql_test 1.0 {
  CREATE TABLE t1(a INTEGER PRIMARY KEY, b);
  INSERT INTO t1 VALUES(1, 'value A');
}

do_apply_v2_test 1.1.1 {
  UPDATE t1 SET b = 'value B' WHERE a=1;
} {
  UPDATE t1 SET b = 'value C' WHERE a=1;
} {
  OMIT
} {
  {INSERT t1 0 X. {} {i 1 t {value B}}}
}
do_apply_v2_test 1.1.2 {
  UPDATE t1 SET b = 'value B' WHERE a=1;
} {
  UPDATE t1 SET b = 'value C' WHERE a=1;
} {
  REPLACE
} {
  {DELETE t1 0 X. {i 1 {} {}} {}}
}

do_apply_v2_test 1.2.1 {
  INSERT INTO t1 VALUES(2, 'first');
} {
  INSERT INTO t1 VALUES(2, 'second');
} {
  OMIT
} {
  {INSERT t1 0 X. {} {i 2 t first}}
}
do_apply_v2_test 1.2.2 {
  INSERT INTO t1 VALUES(2, 'first');
} {
  INSERT INTO t1 VALUES(2, 'second');
} {
  REPLACE
} {
  {DELETE t1 0 X. {i 2 {} {}} {}}
}

do_apply_v2_test 1.3.1 {
  DELETE FROM t1 WHERE a=1;
} {
  UPDATE t1 SET b='value D' WHERE a=1;
} {
  OMIT
} {
  {INSERT t1 1 X. {} {i 1 {} {}}}
}
do_apply_v2_test 1.3.2 {
  DELETE FROM t1 WHERE a=1;
} {
  UPDATE t1 SET b='value D' WHERE a=1;
} {
  REPLACE
} {
  {DELETE t1 0 X. {i 1 {} {}} {}}
}


finish_test
